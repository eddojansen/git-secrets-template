#!/usr/bin/env bash

# Exclude patterns for git-secrets
export GIT_SECRETS_EXCLUDED_DIRS=".*/(venv|env|ENV|\.git|__pycache__|build|dist)/.*"
export GIT_SECRETS_EXCLUDED_FILES="^\.gitallowed$"

# Run git-secrets only on tracked files, excluding specified directories and files
if ! git ls-files | grep -vE "${GIT_SECRETS_EXCLUDED_DIRS}" | grep -vE "${GIT_SECRETS_EXCLUDED_FILES}" | xargs -r git secrets --scan; then
    echo "Git secrets check failed"
    exit 1
fi

# Function to check for potential secrets in staged files
check_secrets() {
    # Common patterns for secrets
    patterns=(
        '[[:alnum:]]{32,}'  # Random strings that might be tokens
        '[0-9a-f]{32,}'     # MD5/SHA hashes
        '[[:alnum:]]{8,}-[[:alnum:]]{4,}-[[:alnum:]]{4,}-[[:alnum:]]{4,}-[[:alnum:]]{12,}'  # UUIDs and similar
        '(password|secret|token|key|credential)[^[:space:]]*[=:][[:space:]]*["'\''"][^"'\'']*["'\''"]' # Key-value pairs with quotes
        '(password|secret|token|key|credential)[^[:space:]]*[=:][[:space:]]*[^[:space:]]+' # Key-value pairs without quotes
        'Bearer[[:space:]]+[[:alnum:]+/=_-]+' # Bearer tokens
        'Authorization:[[:space:]]+[[:alnum:]+/=_-]+' # Auth headers
        'eyJ[[:alnum:]-_=]+\.[[:alnum:]-_=]+\.?[[:alnum:]-_.+/=]*' # JWTs
        '[1-9][0-9]+-[[:alnum:]]{40}' # GitHub tokens
        'ghp_[[:alnum:]]{36}' # GitHub personal access tokens
        'sk_live_[[:alnum:]]{24}' # Stripe keys
        'rk_live_[[:alnum:]]{24}' # Stripe restricted keys
        '[0-9a-f]{32}-us[0-9]{1,2}' # MailChimp API keys
        'AIza[[:alnum:]-_]{35}' # Google API Key
        '[0-9]+-[[:alnum:]_]{32}\.apps\.googleusercontent\.com' # Google OAuth
        'xox[baprs]-[0-9]{12}-[0-9]{12}-[0-9]{12}-[[:alnum:]]{32}' # Slack tokens
        'sk-[[:alnum:]]{48}' # OpenAI API keys
    )

    # Get list of staged files, excluding specified directories and files
    files=$(git diff --cached --name-only | grep -vE "${GIT_SECRETS_EXCLUDED_DIRS}" | grep -vE "${GIT_SECRETS_EXCLUDED_FILES}" || true)

    # Skip binary files and known non-secret files
    for file in $files; do
        [[ -f "$file" ]] || continue
        
        # Skip binary files
        if $(file "$file" | grep -q binary); then
            continue
        fi

        # Skip specific file types
        if [[ "$file" =~ \.(jpg|jpeg|png|gif|ico|svg|woff|woff2|ttf|eot)$ ]]; then
            continue
        fi

        # Check each pattern
        for pattern in "${patterns[@]}"; do
            if grep -EH "$pattern" "$file" 2>/dev/null; then
                echo "Potential secret found in $file"
                echo "Pattern: $pattern"
                echo "Please remove the secret and try again"
                echo "If this is a false positive, add the pattern to .gitallowed"
                exit 1
            fi
        done
    done
}

# Run the secret check
if ! check_secrets; then
    exit 1
fi

# All checks passed
exit 0
